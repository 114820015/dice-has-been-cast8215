<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Dice Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/RoundedBoxGeometry.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        #left-ui {
            position: absolute;
            top: 15px; 
            left: 15px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 6px; 
            pointer-events: none;
            transform-origin: top left;
            transform: scale(0.9); 
        }

        /* Top Battle UI */
        #top-ui {
            position: absolute;
            top: 10px; 
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 80%;
            pointer-events: none;
        }

        #health-bar-container {
            display: flex;
            gap: 2px;
            background: rgba(0,0,0,0.6);
            padding: 4px;
            border-radius: 4px;
            border: 1px solid rgba(255, 50, 50, 0.3);
        }

        .health-segment {
            width: 20px; 
            height: 20px;
            background-color: #F44336; 
            border-radius: 2px;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 5px #F44336;
        }
        .health-lost { 
            background-color: #333; 
            box-shadow: none;
            transform: scale(0.9);
        }

        #boss-counter-panel {
            background: rgba(0, 30, 80, 0.85);
            color: #00d0ff;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 12px;
            border: 1px solid #00d0ff;
            text-shadow: 0 0 5px #00d0ff;
            margin-top: 2px;
        }

        #boss-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: auto;
            background: #000000;
            color: #ff3333;
            border: 2px solid #ff3333;
            padding: 8px 16px;
            font-size: 16px;
            font-weight: 900;
            cursor: pointer;
            display: none;
            z-index: 100;
            border-radius: 8px;
            text-shadow: 0 0 5px #ff0000;
            box-shadow: 0 0 15px rgba(0,0,0,0.6);
            letter-spacing: 2px;
            transition: all 0.3s;
            animation: pulse-red 2s infinite;
        }
        #boss-btn:hover { transform: scale(1.1); background: #222; }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.4); }
            50% { box-shadow: 0 0 25px rgba(255, 0, 0, 0.8); }
            100% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.4); }
        }

        #hud {
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 12px; 
            border-radius: 8px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.06);
            pointer-events: auto;
            display: flex;
            align-items: baseline;
            gap: 8px;
            border: 1px solid rgba(0,0,0,0.05);
        }

        #score-label { font-size: 12px; font-weight: 600; color: #4CAF50; }
        #score-value { font-size: 18px; font-weight: 800; color: #4CAF50; min-width: 30px; }

        #dice-status-panel {
            background: rgba(255, 255, 255, 0.85);
            padding: 8px; 
            border-radius: 8px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            pointer-events: auto;
            border: 1px solid rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
        }
        #dice-status-label { display: none; }
        
        #dice-faces-preview { 
            display: grid; 
            grid-template-columns: repeat(3, 34px); 
            grid-template-rows: repeat(2, 34px);
            gap: 4px; 
        }
        .face-box { 
            width: 34px; 
            height: 34px; 
            border: 1px solid #eee; 
            border-radius: 4px; 
            background: white; 
            background-size: cover;
            opacity: 0.9;
            transition: all 0.2s;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            overflow: hidden;
            cursor: default;
        }
        
        .upgrade-text {
            font-size: 7px; 
            color: #fff;
            background: rgba(0,0,0,0.6);
            width: 100%;
            text-align: center;
            padding: 1px 0;
            font-weight: bold;
            display: block; 
            line-height: 1;
        }

        .face-can-upgrade {
            cursor: pointer;
            box-shadow: 0 0 8px #FFEB3B; 
            border: 2px solid #FFEB3B;     
            animation: pulse-yellow 1.5s infinite;
            transform: scale(1.05);
            z-index: 5;
        }
        .face-can-upgrade:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px #FFEB3B;
        }

        @keyframes pulse-yellow {
            0% { box-shadow: 0 0 3px #FFEB3B; }
            50% { box-shadow: 0 0 10px #FFEB3B; }
            100% { box-shadow: 0 0 3px #FFEB3B; }
        }

        .face-upgraded { transform: scale(1.2) !important; border-color: #ffeb3b !important; box-shadow: 0 0 10px #ffeb3b !important; z-index: 10; }
        .face-downgraded { transform: scale(0.9) !important; border-color: #F44336 !important; box-shadow: 0 0 10px #F44336 !important; filter: grayscale(100%); }

        #action-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
            pointer-events: auto;
            width: 100%;
            margin-bottom: 2px; 
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid #eee;
            padding: 6px 10px; 
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px; 
            font-weight: 600;
            color: #444;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.03);
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 116px; 
        }
        .action-btn:hover { background: #fff; transform: translateY(-1px); }
        .btn-cost { color: #000000; font-size: 10px; font-weight: 700; opacity: 0.7; }

        #instruction {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 11px;
            background: rgba(255,255,255,0.8);
            padding: 5px 14px;
            border-radius: 15px;
            backdrop-filter: blur(4px);
            text-align: center;
        }

        #message-box {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            display: none;
            z-index: 1000;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            pointer-events: none;
            width: max-content;
        }

        #end-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        #end-title { font-size: 48px; font-weight: 900; margin-bottom: 20px; letter-spacing: 5px; }
        #end-stats { font-size: 24px; margin-bottom: 20px; color: #aaa; }
        #end-dice-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px;
        }
        #end-dice-label {
            font-size: 14px;
            margin-bottom: 10px;
            color: #ddd;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #end-dice-preview {
            display: grid;
            grid-template-columns: repeat(3, 50px);
            grid-template-rows: repeat(2, 50px);
            gap: 10px;
        }
        .end-face-box {
            width: 50px;
            height: 50px;
            background: white;
            background-size: cover;
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
        }

        #restart-btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        #restart-btn:hover { transform: scale(1.1); }

        .score-up { animation: bounce 0.5s; color: #4CAF50 !important; }
        .score-down { animation: shake 0.4s; color: #4CAF50 !important; }
        @keyframes bounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
    </style>
</head>
<body>
    <div id="top-ui">
        <div id="health-bar-container" style="display:none;">
            <!-- JS will inject segments here -->
        </div>
        <div id="boss-counter-panel" style="display:none;">
            BOSS ACTION IN: <span id="boss-moves-left">-</span>
        </div>
    </div>

    <div id="left-ui">
        <div id="hud">
            <div id="score-label">Score</div>
            <div id="score-value">0</div>
        </div>
        <div id="action-buttons">
            <button class="action-btn" onclick="randomDiceTeleport()">
                <span>TELEPORT</span> <span class="btn-cost">500</span>
            </button>
        </div>
        <div id="dice-status-panel">
            <div id="dice-faces-preview">
                <div class="face-box" id="f-0" onclick="tryUpgradeFace(0)"><span class="upgrade-text">UP 100</span></div>
                <div class="face-box" id="f-1" onclick="tryUpgradeFace(1)"><span class="upgrade-text">UP 100</span></div>
                <div class="face-box" id="f-2" onclick="tryUpgradeFace(2)"><span class="upgrade-text">UP 100</span></div>
                <div class="face-box" id="f-3" onclick="tryUpgradeFace(3)"><span class="upgrade-text">UP 100</span></div>
                <div class="face-box" id="f-4" onclick="tryUpgradeFace(4)"><span class="upgrade-text">UP 100</span></div>
                <div class="face-box" id="f-5" onclick="tryUpgradeFace(5)"><span class="upgrade-text">UP 100</span></div>
            </div>
        </div>
    </div>
    
    <button id="boss-btn" onclick="triggerBoss()">BOSS</button>

    <div id="message-box"></div>
    <div id="instruction">
        <b>[SPACE]</b> Roll | <b>[CLICK]</b> Move | Clear Beams to Win
    </div>

    <div id="end-screen">
        <div id="end-title">GAME OVER</div>
        <div id="end-dice-container">
            <div id="end-dice-label">Final Dice State</div>
            <div id="end-dice-preview">
                <!-- JS will populate this -->
            </div>
        </div>
        <div id="end-stats">Total Rolls: <span id="total-tosses-val">0</span></div>
        <button id="restart-btn" onclick="location.reload()">RETRY</button>
    </div>

    <script>
        let scene, camera, renderer, dice, board;
        let bossDice = null;
        let beams = []; 
        let particles = []; 
        
        let bossActive = false;
        let playerMovesSinceBoss = 0;
        let bossLastRoll = 4; 
        let nextBossThreshold = 6; 
        let bossHP = 12; 
        const MAX_HP = 12; 
        let totalTosses = 0;
        let totalPlayerMoves = 0; 

        const diceSize = 0.56; 
        const gridSize = 19; 
        const cellSize = 1;
        const halfBoard = (gridSize - 1) / 2; 
        const bossFloatHeight = 1.0; 

        let isMoving = false;
        let hasMovedSinceLastToss = true; 
        let totalScore = 100; 
        let pathGroup = null; 
        let cameraAzimuth = 0; 
        let cameraPolar = 0.8; 
        let isMouseDown = false;
        
        // Camera Shake
        let shakeIntensity = 0;
        let shakeDecay = 0.9;
        let focusTarget = null;

        // Cinematic Camera
        let isCinematic = false;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let diceFacePoints = [1, 1, 1, 2, 2, 2]; 

        const chipsConfig = [
            { val: 50, color: '#4CAF50' },
            { val: 100, color: '#2196F3' },
            { val: 150, color: '#FFD700' }
        ];

        let collectibleObjects = []; 
        const PATH_COLOR = 0x00FF00; 
        const OPACITY_NORMAL = 0.05;
        const OPACITY_TARGET = 0.15;
        const OPACITY_HOVER_NORMAL = 0.12;
        const OPACITY_HOVER_TARGET = 0.35;
        const occupiedLocations = new Map(); 

        function generatePointCanvas(point) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = '#eeeeee'; ctx.lineWidth = 4; ctx.strokeRect(0, 0, 256, 256);
            ctx.fillStyle = (point === 1 || point === 4) ? '#ff4d4d' : '#333333';
            const radius = point === 1 ? 48 : 32;
            const posMap = {
                1: [[128, 128]], 2: [[70, 70], [186, 186]], 3: [[60, 60], [128, 128], [196, 196]],
                4: [[75, 75], [181, 75], [75, 181], [181, 181]], 5: [[75, 75], [181, 75], [128, 128], [75, 181], [181, 181]],
                6: [[75, 60], [75, 128], [75, 196], [181, 60], [181, 128], [181, 196]]
            };
            (posMap[point] || []).forEach(p => { ctx.beginPath(); ctx.arc(p[0], p[1], radius, 0, Math.PI * 2); ctx.fill(); });
            return canvas;
        }

        function createDice() {
            const geometry = new THREE.RoundedBoxGeometry(diceSize, diceSize, diceSize, 3, 0.08);
            const materials = [];
            for(let i=0; i<6; i++) { 
                materials.push(new THREE.MeshPhongMaterial({ 
                    map: new THREE.CanvasTexture(generatePointCanvas(diceFacePoints[i])),
                    emissive: new THREE.Color(0x000000)
                })); 
            }
            dice = new THREE.Mesh(geometry, materials);
            dice.position.y = diceSize / 2; dice.castShadow = true;
            scene.add(dice);
        }

        function init() {
            initHealthBar();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(10, 20, 10);
            light.castShadow = true;
            scene.add(light);

            createBoard();
            createMapContent();
            createDice();
            
            focusTarget = dice;

            updateDiceUI();
            updateCameraPosition();
            updateScoreUI(); 

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => { if(e.code === 'Space') performToss(); });
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', () => isMouseDown = false);
            animate();
        }

        function initHealthBar() {
            const container = document.getElementById('health-bar-container');
            container.innerHTML = '';
            for (let i = 0; i < MAX_HP; i++) {
                const seg = document.createElement('div');
                seg.className = 'health-segment';
                seg.id = `hp-${i}`;
                container.appendChild(seg);
            }
        }

        function updateHealthUI() {
            for (let i = 0; i < MAX_HP; i++) {
                const seg = document.getElementById(`hp-${i}`);
                if (i < bossHP) {
                    seg.classList.remove('health-lost');
                } else {
                    seg.classList.add('health-lost');
                }
            }
        }

        function updateBossCounter() {
            const el = document.getElementById('boss-moves-left');
            nextBossThreshold = 2 + bossLastRoll; 
            const movesLeft = Math.max(0, nextBossThreshold - playerMovesSinceBoss);
            el.innerText = movesLeft;
        }

        function updateDiceUI(highlightIndex = -1, downgradeIndex = -1) {
            diceFacePoints.forEach((pts, i) => {
                const el = document.getElementById(`f-${i}`);
                if (!el) return;
                const canvas = generatePointCanvas(pts);
                el.style.backgroundImage = `url(${canvas.toDataURL()})`;
                
                el.classList.remove('face-upgraded', 'face-downgraded', 'face-can-upgrade');

                if (totalScore >= 100 && pts < 6 && hasMovedSinceLastToss && !isMoving) {
                    el.classList.add('face-can-upgrade');
                }

                if (i === highlightIndex) {
                    el.classList.add('face-upgraded');
                    setTimeout(() => el.classList.remove('face-upgraded'), 600);
                }
                
                if (i === downgradeIndex) {
                    el.classList.add('face-downgraded');
                    setTimeout(() => el.classList.remove('face-downgraded'), 600);
                }
            });
        }

        function updateScoreUI() {
            const scoreEl = document.getElementById('score-value');
            scoreEl.innerText = totalScore.toLocaleString();
            updateDiceUI(); 
        }

        function showMessage(text, color = "white", duration = 2500) {
            const box = document.getElementById('message-box');
            box.innerText = text;
            box.style.color = color;
            box.style.display = 'block';
            setTimeout(() => { box.style.display = 'none'; }, duration);
        }

        function tryUpgradeFace(index) {
            if (isMoving) return;
            if (!hasMovedSinceLastToss) {
                showMessage("Roll already cast! Move first!", "#F44336");
                return;
            }

            if (totalScore < 100) return;
            if (diceFacePoints[index] >= 6) {
                showMessage("MAX LEVEL!", "#F44336");
                return; 
            }

            subtractScore(100);
            diceFacePoints[index]++;
            
            const newTex = new THREE.CanvasTexture(generatePointCanvas(diceFacePoints[index]));
            dice.material[index].map = newTex;
            dice.material[index].needsUpdate = true;
            
            flashDice();
            updateDiceUI(index);
            showMessage(`Face Upgraded to ${diceFacePoints[index]}!`, "#ffeb3b");
        }

        function downgradeRandomFace() {
            let eligibleIndices = [];
            diceFacePoints.forEach((pts, i) => { if(pts > 1) eligibleIndices.push(i); });
            
            if (eligibleIndices.length > 0) {
                const targetIdx = eligibleIndices[Math.floor(Math.random() * eligibleIndices.length)];
                diceFacePoints[targetIdx]--;
                
                const newTex = new THREE.CanvasTexture(generatePointCanvas(diceFacePoints[targetIdx]));
                dice.material[targetIdx].map = newTex;
                dice.material[targetIdx].needsUpdate = true;
                
                updateDiceUI(-1, targetIdx);
                showMessage(`Face Downgraded to ${diceFacePoints[targetIdx]}!`, "#F44336");
            } else {
                showMessage("All faces at minimum!", "#F44336");
            }
        }

        function checkBossUnlock() {
            // Not used button anymore, auto trigger
        }

        function triggerBoss() {
            const btn = document.getElementById('boss-btn');
            btn.style.display = 'none';

            bossActive = true;
            playerMovesSinceBoss = 0;
            document.getElementById('boss-counter-panel').style.display = 'block';
            document.getElementById('health-bar-container').style.display = 'flex';
            updateBossCounter();
            updateHealthUI();

            scene.background = new THREE.Color(0x2d1b4e);

            const enemiesToRemove = [];
            collectibleObjects.forEach((obj) => {
                if (obj.userData.type === 'enemy') {
                    enemiesToRemove.push(obj);
                }
            });

            enemiesToRemove.forEach(enemy => {
                const x = enemy.userData.x;
                const z = enemy.userData.z;
                
                const startScaleY = enemy.scale.y;
                let squashFrame = 0;
                const squashDuration = 20;

                function animateSquash() {
                    squashFrame++;
                    const progress = squashFrame / squashDuration;
                    
                    if (progress < 1) {
                        enemy.scale.y = startScaleY * (1 - progress);
                        enemy.position.y = (0.45 * enemy.scale.y) / 2; 
                        requestAnimationFrame(animateSquash);
                    } else {
                        scene.remove(enemy);
                        occupiedLocations.delete(`${x},${z}`);
                        create3DChip(x, z, { val: 50, color: '#4CAF50' });
                        occupiedLocations.set(`${x},${z}`, 'chip');
                    }
                }
                animateSquash();
            });
            
            collectibleObjects = collectibleObjects.filter(obj => obj.userData.type !== 'enemy');

            showMessage("BOSS SPAWNED! ENEMIES CRUSHED!", "#00d0ff");

            const bossSize = diceSize * 2.4; 
            const geometry = new THREE.RoundedBoxGeometry(bossSize, bossSize, bossSize, 4, 0.2);
            const materials = [];
            for(let i=1; i<=6; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000000'; ctx.fillRect(0,0,256,256);
                ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 10; ctx.strokeRect(0,0,256,256);
                ctx.fillStyle = '#ffffff';
                const radius = 24; 
                const posMap = {
                    1: [[128, 128]], 
                    2: [[70, 70], [186, 186]], 
                    3: [[60, 60], [128, 128], [196, 196]],
                    4: [[75, 75], [181, 75], [75, 181], [181, 181]], 
                    5: [[75, 75], [181, 75], [128, 128], [75, 181], [181, 181]],
                    6: [[75, 60], [75, 128], [75, 196], [181, 60], [181, 128], [181, 196]]
                };
                (posMap[i] || []).forEach(p => { ctx.beginPath(); ctx.arc(p[0], p[1], radius, 0, Math.PI * 2); ctx.fill(); });
                materials.push(new THREE.MeshPhongMaterial({ map: new THREE.CanvasTexture(canvas), emissive: new THREE.Color(0x330000) }));
            }
            
            bossDice = new THREE.Mesh(geometry, materials);
            bossDice.position.set(0, 20, 0); 
            bossDice.castShadow = true;
            scene.add(bossDice);
            
            // Set Focus to Boss and Camera Angle
            focusTarget = bossDice;
            // Angle from player to boss center is tricky, lets just look from behind player
            const playerAngleFromBoss = Math.atan2(dice.position.x, dice.position.z);
            cameraAzimuth = playerAngleFromBoss + Math.PI; // Behind player looking at 0,0
            cameraPolar = Math.PI/2 - (35 * Math.PI/180); // 35 degrees up
            
            isCinematic = true;
            isMoving = true; // Lock player

            // Unlock after 2 seconds
            setTimeout(() => {
                isCinematic = false;
                isMoving = false;
                // Don't revert focus target, keep it dynamic or revert to dice? 
                // Usually game play focuses on dice.
                focusTarget = dice; 
                // But we want to see boss actions? The existing updateCameraPosition focuses on dice usually.
                // Let's keep it on dice for gameplay, boss is big enough.
            }, 2000);

            let velocity = 0;
            const gravity = 0.02;
            const groundY = bossSize / 2 + bossFloatHeight; 

            function animateBossDrop() {
                velocity += gravity;
                bossDice.position.y -= velocity;
                bossDice.rotation.x += 0.05;
                bossDice.rotation.z += 0.02;

                if (bossDice.position.y <= groundY) {
                    bossDice.position.y = groundY;
                    bossDice.rotation.set(0, 0, 0); 
                    
                    shakeCamera(0.5); 
                    showMessage("Hit the beam!", "#ff3333");

                    setTimeout(() => bossTurn(), 1000); 
                    return; 
                }
                requestAnimationFrame(animateBossDrop);
            }
            animateBossDrop();
        }

        function shakeCamera(intensity) {
            shakeIntensity = intensity;
        }

        async function bossTurn() {
            if (bossHP <= 0) return; 
            
            isMoving = true; 
            
            const bossSize = diceSize * 2.4; 
            const floatY = bossSize / 2 + bossFloatHeight;

            const duration = 50; 
            let frame = 0;
            const startQuat = bossDice.quaternion.clone();
            const axis = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            const totalRot = Math.PI * 6 + Math.random() * Math.PI * 4;
            
            const curX = bossDice.position.x; 
            const curZ = bossDice.position.z;

            await new Promise(resolve => {
                function animateBossToss() {
                    frame++; 
                    const t = frame / duration;
                    if (frame <= duration) {
                        bossDice.position.y = floatY + Math.sin(t * Math.PI) * 8; 
                        const currentRot = new THREE.Quaternion().setFromAxisAngle(axis, totalRot * t);
                        bossDice.quaternion.copy(startQuat).premultiply(currentRot);
                        requestAnimationFrame(animateBossToss);
                    } else {
                        bossDice.position.set(curX, floatY, curZ);
                        const euler = new THREE.Euler().setFromQuaternion(bossDice.quaternion);
                        euler.x = Math.round(euler.x / (Math.PI / 2)) * (Math.PI / 2);
                        euler.y = Math.round(euler.y / (Math.PI / 2)) * (Math.PI / 2);
                        euler.z = Math.round(euler.z / (Math.PI / 2)) * (Math.PI / 2);
                        bossDice.quaternion.setFromEuler(euler);
                        
                        shakeCamera(0.3);
                        resolve();
                    }
                }
                animateBossToss();
            });

            bossLastRoll = Math.floor(Math.random() * 6) + 1; 
            showMessage("Hit the beam!", "#ff3333");
            
            spawnBeams(bossLastRoll);
            
            playerMovesSinceBoss = 0;
            updateBossCounter(); 
            isMoving = false; 
        }

        function spawnBeams(count) {
            for(let i=0; i<count; i++) {
                let bx, bz;
                let attempts = 0;
                do {
                    bx = Math.floor(Math.random() * gridSize) - halfBoard;
                    bz = Math.floor(Math.random() * gridSize) - halfBoard;
                    attempts++;
                } while (
                    (bx === 0 && bz === 0) || 
                    (bx === Math.round(dice.position.x) && bz === Math.round(dice.position.z)) 
                    && attempts < 50
                );

                const existing = beams.find(b => b.userData.x === bx && b.userData.z === bz);
                if (!existing) {
                    const h = 10;
                    const geo = new THREE.CylinderGeometry(0.4, 0.4, h, 16);
                    const mat = new THREE.MeshPhongMaterial({
                        color: 0x2a003b,
                        emissive: 0xaa00ff,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.4 
                    });
                    const beam = new THREE.Mesh(geo, mat);
                    beam.position.set(bx, h/2, bz);
                    beam.userData = { x: bx, z: bz, type: 'beam' };
                    
                    scene.add(beam);
                    beams.push(beam);
                }
            }

            if (beams.length >= 21) {
                gameOver(false, "OVERLOAD! WORLD DESTROYED!");
            } else if (beams.length >= 15) {
                showMessage("WARNING!", "#ff0000", 4000);
            }
        }

        async function checkBeamCollision(x, z) {
            const index = beams.findIndex(b => b.userData.x === Math.round(x) && b.userData.z === Math.round(z));
            if (index !== -1) {
                const beam = beams[index];
                scene.remove(beam);
                beams.splice(index, 1);
                
                bossHP--;
                updateHealthUI();
                
                showMessage("HIT!", "#4CAF50");
                
                if (bossHP <= 0) {
                    await animateBossDefeat();
                    return true; 
                }
            }
            return false;
        }

        async function animateBossDefeat() {
            isMoving = true; 
            showMessage("BOSS EXPLODING...", "#ff00ff");
            
            focusTarget = bossDice;
            
            // Camera Cinematic Angle: 35 degrees up
            const playerAngleFromBoss = Math.atan2(dice.position.x - bossDice.position.x, dice.position.z - bossDice.position.z);
            
            const duration = 120; 

            for(let i=0; i<50; i++) {
                const pGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const pMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const p = new THREE.Mesh(pGeo, pMat);
                p.position.copy(bossDice.position);
                p.userData.vel = new THREE.Vector3(
                    (Math.random()-0.5) * 1.5, 
                    (Math.random()-0.5) * 1.5, 
                    (Math.random()-0.5) * 1.5
                );
                scene.add(p);
                particles.push(p);
            }

            const startAzimuth = cameraAzimuth;
            const startPolar = cameraPolar;

            for(let f=0; f<duration; f++) {
                const t = f/duration;
                
                cameraAzimuth = startAzimuth + (playerAngleFromBoss - startAzimuth) * t; 
                cameraPolar = startPolar + ((Math.PI/2 - (35 * Math.PI/180)) - startPolar) * t;

                const scale = 1 + t * 4; 
                bossDice.scale.set(scale, scale, scale);
                
                bossDice.position.x += (Math.random()-0.5) * 0.5;
                bossDice.position.y += (Math.random()-0.5) * 0.5;
                bossDice.position.z += (Math.random()-0.5) * 0.5;

                const intensity = (f % 5) * 0.2;
                bossDice.material.forEach(m => {
                    m.emissive.setRGB(1, 1 - intensity, 1 - intensity);
                    m.emissiveIntensity = 1 + t * 5;
                    m.transparent = true;
                    m.opacity = 0.7; 
                });

                if (t > 0.5) {
                    particles.forEach(p => {
                        p.position.add(p.userData.vel);
                        p.rotation.x += 0.2;
                        p.rotation.y += 0.2;
                    });
                }

                await new Promise(requestAnimationFrame);
            }
            
            scene.remove(bossDice);
            particles.forEach(p => scene.remove(p));
            particles = [];
            
            await new Promise(resolve => setTimeout(resolve, 2000));

            gameOver(true, "ALL BEAMS CLEARED! BOSS DEFEATED!");
        }

        function gameOver(win, msg) {
            isMoving = true; 
            document.getElementById('end-screen').style.display = 'flex';
            document.getElementById('end-title').innerText = win ? "CONGRATULATION" : "GAME OVER";
            document.getElementById('end-title').style.color = win ? "#4CAF50" : "#F44336";
            document.getElementById('total-tosses-val').innerText = totalTosses;
            showMessage(msg, win ? "#4CAF50" : "#F44336");

            const previewContainer = document.getElementById('end-dice-preview');
            previewContainer.innerHTML = '';
            diceFacePoints.forEach(pts => {
                const div = document.createElement('div');
                div.className = 'end-face-box';
                const canvas = generatePointCanvas(pts);
                div.style.backgroundImage = `url(${canvas.toDataURL()})`;
                previewContainer.appendChild(div);
            });
        }

        function createBoard() {
            const size = gridSize * cellSize;
            const geometry = new THREE.PlaneGeometry(size, size);
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff }); 
            board = new THREE.Mesh(geometry, material);
            board.rotation.x = -Math.PI / 2;
            board.receiveShadow = true;
            scene.add(board);
            const gridHelper = new THREE.GridHelper(size, gridSize, 0xb0b0b0, 0xc0c0c0);
            gridHelper.position.y = 0.001; 
            scene.add(gridHelper);
        }

        function addScore(points) {
            totalScore += points;
            const scoreEl = document.getElementById('score-value');
            scoreEl.innerText = totalScore.toLocaleString();
            scoreEl.classList.remove('score-up');
            void scoreEl.offsetWidth; scoreEl.classList.add('score-up');
            updateDiceUI(); 
        }

        function subtractScore(points) {
            totalScore = Math.max(0, totalScore - points);
            const scoreEl = document.getElementById('score-value');
            scoreEl.innerText = totalScore.toLocaleString();
            scoreEl.classList.remove('score-down');
            void scoreEl.offsetWidth; scoreEl.classList.add('score-down');
            updateDiceUI(); 
        }

        function snapDiceRotation() {
            const euler = new THREE.Euler().setFromQuaternion(dice.quaternion);
            euler.x = Math.round(euler.x / (Math.PI / 2)) * (Math.PI / 2);
            euler.y = Math.round(euler.y / (Math.PI / 2)) * (Math.PI / 2);
            euler.z = Math.round(euler.z / (Math.PI / 2)) * (Math.PI / 2);
            dice.quaternion.setFromEuler(euler);
        }

        function getUpwardFace() {
            const vector = new THREE.Vector3(0, 1, 0);
            vector.applyQuaternion(dice.quaternion.clone().invert());
            let maxDot = -1, faceIndex = -1;
            const fv = [new THREE.Vector3(1,0,0),new THREE.Vector3(-1,0,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,-1,0),new THREE.Vector3(0,0,1),new THREE.Vector3(0,0,-1)];
            fv.forEach((v, i) => { const dot = v.dot(vector); if (dot > maxDot) { maxDot = dot; faceIndex = i; } });
            return diceFacePoints[faceIndex];
        }

        function performToss() {
            if(isMoving) return;
            if (!hasMovedSinceLastToss) { showMessage("Move First!"); return; }
            
            isMoving = true;
            if (pathGroup) { scene.remove(pathGroup); pathGroup = null; }
            
            totalTosses++; 

            // Auto Trigger Boss if condition met
            if (totalTosses === 25 && !bossActive) {
                triggerBoss();
                return;
            }

            const duration = 50; let frame = 0;
            const startQuat = dice.quaternion.clone();
            const axis = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            const totalRot = Math.PI * 6 + Math.random() * Math.PI * 4;
            const curX = dice.position.x, curZ = dice.position.z;
            function animateToss() {
                frame++; const t = frame / duration;
                if (frame <= duration) {
                    dice.position.y = (diceSize/2) + Math.sin(t * Math.PI) * 2.5;
                    const currentRot = new THREE.Quaternion().setFromAxisAngle(axis, totalRot * t);
                    dice.quaternion.copy(startQuat).premultiply(currentRot);
                    requestAnimationFrame(animateToss);
                } else {
                    dice.position.set(curX, diceSize / 2, curZ);
                    snapDiceRotation(); 
                    
                    showPath(getUpwardFace()); 
                    hasMovedSinceLastToss = false;
                    
                    isMoving = false;
                    updateDiceUI(); 
                }
            }
            animateToss();
        }

        function flashDice() {
            const originalEmissive = new THREE.Color(0x000000);
            const flashColor = new THREE.Color(0xffff00);
            let frame = 0; const duration = 30;
            function animateFlash() {
                frame++; const t = frame / duration;
                const intensity = Math.sin(t * Math.PI) * 0.8;
                dice.material.forEach(mat => { mat.emissive.lerpColors(originalEmissive, flashColor, intensity); });
                if (frame < duration) requestAnimationFrame(animateFlash);
                else dice.material.forEach(mat => mat.emissive.set(0x000000));
            }
            animateFlash();
        }

        async function randomDiceTeleport() {
            if (isMoving) return;
            if (!hasMovedSinceLastToss) { showMessage("Already rolled! Move now!"); return; }

            if (totalScore < 500) { showMessage("Need more score (500)!"); return; }
            subtractScore(500);
            const rx = Math.floor(Math.random() * gridSize) - halfBoard;
            const rz = Math.floor(Math.random() * gridSize) - halfBoard;
            isMoving = true;
            if (pathGroup) { scene.remove(pathGroup); pathGroup = null; }
            const targetPos = new THREE.Vector3(rx, diceSize/2, rz);
            for (let f = 1; f <= 25; f++) {
                const t = f / 25;
                if (f <= 12) { dice.scale.set(1-t*2, 1-t*2, 1-t*2); }
                else if (f <= 25) {
                    dice.position.copy(targetPos);
                    const t2 = (f-12)/13;
                    dice.scale.set(t2, t2, t2);
                }
                await new Promise(requestAnimationFrame);
            }
            dice.scale.set(1,1,1);
            snapDiceRotation();
            checkChipCollection(rx, rz);
            
            hasMovedSinceLastToss = true; 
            
            isMoving = false;
            updateDiceUI(); 
        }

        function showPath(points) {
            if (pathGroup) scene.remove(pathGroup);
            pathGroup = new THREE.Group();
            const directions = [{n:'xp',x:1,z:0},{n:'xn',x:-1,z:0},{n:'zp',x:0,z:1},{n:'zn',x:0,z:-1}];
            directions.forEach(baseDir => {
                const pathData = calculatePath(dice.position, baseDir, points);
                pathData.forEach((step, i) => {
                    const geometry = new THREE.PlaneGeometry(0.95, 0.95);
                    const isTarget = (i === points && i > 0);
                    const material = new THREE.MeshBasicMaterial({
                        color: PATH_COLOR, transparent: true, 
                        opacity: isTarget ? OPACITY_TARGET : OPACITY_NORMAL,
                        side: THREE.DoubleSide, depthWrite: false
                    });
                    const stepMesh = new THREE.Mesh(geometry, material);
                    stepMesh.rotation.x = -Math.PI / 2;
                    stepMesh.position.set(step.x, 0.003, step.z);
                    stepMesh.userData = { directionName: baseDir.n, isTarget: isTarget, fullPath: pathData };
                    pathGroup.add(stepMesh);
                });
            });
            scene.add(pathGroup);
        }

        function calculatePath(startPos, dir, points) {
            let path = [{ x: Math.round(startPos.x), z: Math.round(startPos.z) }];
            let curX = path[0].x, curZ = path[0].z, dx = dir.x, dz = dir.z;
            for (let i = 1; i <= points; i++) {
                let nx = curX + dx, nz = curZ + dz;
                if (nx > halfBoard || nx < -halfBoard) { dx = -dx; nx = curX + dx; }
                if (nz > halfBoard || nz < -halfBoard) { dz = -dz; nz = curZ + dz; }
                curX = nx; curZ = nz;
                path.push({ x: curX, z: curZ, dx, dz });
            }
            return path;
        }

        function onMouseDown(e) {
            isMouseDown = true;
            if (isMoving || !pathGroup) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            dice.visible = false;
            const intersects = raycaster.intersectObjects(pathGroup.children);
            dice.visible = true;
            if (intersects.length > 0) {
                const targetObj = intersects.find(intersect => intersect.object.userData.isTarget) || intersects[0];
                const finalTarget = pathGroup.children.find(child => child.userData.directionName === targetObj.object.userData.directionName && child.userData.isTarget);
                if (finalTarget) rollDiceAlongPath(finalTarget.userData.fullPath);
            }
        }

        function onMouseMove(e) {
            if (isMouseDown && !isCinematic) { // Block mouse move during cinematic
                cameraAzimuth -= e.movementX * 0.005;
                cameraPolar += e.movementY * 0.005;
                cameraPolar = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraPolar));
            }
            if (isMoving || !pathGroup) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            dice.visible = false;
            const intersects = raycaster.intersectObjects(pathGroup.children);
            dice.visible = true;
            pathGroup.children.forEach(child => child.material.opacity = child.userData.isTarget ? OPACITY_TARGET : OPACITY_NORMAL);
            if (intersects.length > 0) {
                const dirName = intersects[0].object.userData.directionName;
                pathGroup.children.forEach(child => {
                    if (child.userData.directionName === dirName) {
                        child.material.opacity = child.userData.isTarget ? OPACITY_HOVER_TARGET : OPACITY_HOVER_NORMAL;
                    }
                });
            }
        }

        async function rollDiceAlongPath(path) {
            isMoving = true;
            if (pathGroup) { scene.remove(pathGroup); pathGroup = null; }
            
            totalPlayerMoves++;

            for (let s = 1; s < path.length; s++) {
                const step = path[s], prev = path[s-1];
                const enemy = getObjectAt(step.x, step.z, 'enemy');
                
                if (await checkBeamCollision(step.x, step.z)) return; 

                if (enemy) {
                    showMessage("FIGHT!", "#ff4d4d");
                    await combatTossAnimation(enemy);
                    const myPoint = getUpwardFace();
                    const enemyPoint = enemy.userData.points;

                    if (myPoint >= enemyPoint) {
                        showMessage(`Bigger!`, "#4CAF50");
                        addScore(100);
                        await performCrushMove(prev, step, enemy);
                        scene.remove(enemy);
                        collectibleObjects = collectibleObjects.filter(o => o !== enemy);
                        occupiedLocations.delete(`${enemy.userData.x},${enemy.userData.z}`);
                        checkChipCollection(step.x, step.z);
                    } else {
                        if (totalScore - 50 < 0) {
                            totalScore = 0;
                            updateScoreUI(); 
                            downgradeRandomFace();
                        } else {
                            subtractScore(50);
                            showMessage(`Smaller!`, "#F44336");
                        }
                        
                        hasMovedSinceLastToss = true; 
                        
                        if(bossActive) {
                            playerMovesSinceBoss++;
                            updateBossCounter();
                            if(playerMovesSinceBoss >= nextBossThreshold || beams.length === 0) {
                                isMoving = false; 
                                await bossTurn();
                            }
                        }
                        isMoving = false;
                        return;
                    }
                } else {
                    await performSingleMove(prev, step);
                    checkChipCollection(step.x, step.z);
                }
            }

            hasMovedSinceLastToss = true;
            isMoving = false;
            updateDiceUI();
            
            if (bossActive) {
                playerMovesSinceBoss++;
                updateBossCounter();
                
                if (playerMovesSinceBoss >= nextBossThreshold || beams.length === 0) {
                    await bossTurn();
                }
            }
        }

        async function performCrushMove(from, to, enemy) {
            const stepDir = { x: to.x - from.x, z: to.z - from.z };
            const rotationAxis = new THREE.Vector3(stepDir.z, 0, -stepDir.x).normalize();
            const startPos = dice.position.clone();
            const startQuat = dice.quaternion.clone();
            const targetPos = new THREE.Vector3(to.x, diceSize/2, to.z);
            
            const frames = 15;
            for (let f = 1; f <= frames; f++) {
                const t = f / frames;
                dice.position.lerpVectors(startPos, targetPos, t);
                dice.position.y = (diceSize/2) + Math.sin(t * Math.PI) * 1.2;
                
                const stepQuat = new THREE.Quaternion().setFromAxisAngle(rotationAxis, (Math.PI / 2) * t);
                dice.quaternion.copy(startQuat).premultiply(stepQuat);

                if (t > 0.6) {
                    const crushT = (t - 0.6) / 0.4;
                    enemy.scale.y = 1 - crushT * 0.9;
                    enemy.position.y = (0.45 * enemy.scale.y) / 2;
                }
                
                await new Promise(requestAnimationFrame);
            }
            
            dice.position.copy(targetPos);
            snapDiceRotation();

            const originalY = dice.position.y;
            for(let i=0; i<6; i++){
                dice.position.y = originalY + (i % 2 === 0 ? 0.05 : 0);
                await new Promise(requestAnimationFrame);
            }
            dice.position.y = originalY;
        }

        async function performSingleMove(from, to) {
            const stepDir = { x: to.x - from.x, z: to.z - from.z };
            const rotationAxis = new THREE.Vector3(stepDir.z, 0, -stepDir.x).normalize();
            const startPos = dice.position.clone();
            const startQuat = dice.quaternion.clone();
            const targetPos = new THREE.Vector3(to.x, diceSize/2, to.z);
            
            for (let f = 1; f <= 8; f++) {
                const t = f / 8;
                dice.position.lerpVectors(startPos, targetPos, t);
                dice.position.y = (diceSize/2) + Math.sin(t * Math.PI) * 0.2;
                const stepQuat = new THREE.Quaternion().setFromAxisAngle(rotationAxis, (Math.PI / 2) * t);
                dice.quaternion.copy(startQuat).premultiply(stepQuat);
                await new Promise(requestAnimationFrame);
            }
            dice.position.copy(targetPos);
            snapDiceRotation();
        }

        async function combatTossAnimation(enemy) {
            const combatDuration = 30;
            const axis = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            const eAxis = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            
            const startQuat = dice.quaternion.clone();
            const eStartQuat = enemy.quaternion.clone();
            const rotSpeed = Math.PI * 6;
            const startY = dice.position.y;
            const eStartY = enemy.position.y;

            for (let f = 1; f <= combatDuration; f++) {
                const t = f / combatDuration;
                dice.position.y = startY + Math.sin(t * Math.PI) * 1.8;
                const currentRot = new THREE.Quaternion().setFromAxisAngle(axis, rotSpeed * t);
                dice.quaternion.copy(startQuat).premultiply(currentRot);
                
                enemy.position.y = eStartY + Math.sin(t * Math.PI) * 1.2;
                const eRot = new THREE.Quaternion().setFromAxisAngle(eAxis, rotSpeed * t);
                enemy.quaternion.copy(eStartQuat).premultiply(eRot);
                
                await new Promise(requestAnimationFrame);
            }
            
            dice.position.y = diceSize / 2;
            enemy.position.y = 0.45 / 2;
            
            snapDiceRotation();
            const eEuler = new THREE.Euler().setFromQuaternion(enemy.quaternion);
            eEuler.x = Math.round(eEuler.x / (Math.PI / 2)) * (Math.PI / 2);
            eEuler.y = Math.round(eEuler.y / (Math.PI / 2)) * (Math.PI / 2);
            eEuler.z = Math.round(eEuler.z / (Math.PI / 2)) * (Math.PI / 2);
            enemy.quaternion.setFromEuler(eEuler);
            
            await new Promise(resolve => setTimeout(resolve, 600)); 
        }

        function getObjectAt(x, z, type) {
            const rx = Math.round(x); const rz = Math.round(z);
            return collectibleObjects.find(o => o.userData.x === rx && o.userData.z === rz && o.userData.type === type);
        }

        function checkChipCollection(x, z) {
            const chip = getObjectAt(x, z, 'chip');
            if (chip) {
                addScore(chip.userData.value);
                scene.remove(chip);
                collectibleObjects = collectibleObjects.filter(o => o !== chip);
                occupiedLocations.delete(`${chip.userData.x},${chip.userData.z}`);
            }
        }

        function updateCameraPosition() {
            const dist = 9;
            const target = focusTarget ? focusTarget.position : dice.position;
            
            const shakeX = (Math.random() - 0.5) * shakeIntensity;
            const shakeY = (Math.random() - 0.5) * shakeIntensity;
            const shakeZ = (Math.random() - 0.5) * shakeIntensity;
            
            camera.position.set(
                Math.sin(cameraAzimuth) * Math.cos(cameraPolar) * dist + target.x + shakeX,
                Math.sin(cameraPolar) * dist + target.y + shakeY,
                Math.sin(cameraAzimuth + Math.PI/2) * Math.cos(cameraPolar) * dist + target.z + shakeZ
            );
            camera.lookAt(target.x, target.y, target.z);
            
            shakeIntensity *= shakeDecay;
            if(shakeIntensity < 0.01) shakeIntensity = 0;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateCameraPosition();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
