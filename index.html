<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 骰子冒險 - 螢光優化版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/RoundedBoxGeometry.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: sans-serif; }
        
        /* 頂部左側固定面板 */
        #left-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 12px;
            pointer-events: none;
        }

        /* 積分 HUD */
        #hud {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            pointer-events: auto;
            display: flex;
            align-items: baseline;
            gap: 8px;
            border: 1px solid rgba(0,0,0,0.05);
        }

        #score-label { font-size: 16px; font-weight: 600; color: #666; }
        #score-value { font-size: 24px; font-weight: 800; color: #1a1a1a; min-width: 50px; }

        /* 骰子點數橫條 */
        #dice-faces-strip {
            display: flex;
            gap: 6px;
            background: rgba(255, 255, 255, 0.6);
            padding: 6px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            pointer-events: auto;
            border: 1px solid rgba(0,0,0,0.03);
        }

        .face-box {
            width: 28px;
            height: 28px;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* 動作按鈕區域 */
        #action-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
            width: 100%;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #eee;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #333;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 6px rgba(0,0,0,0.04);
            text-align: center;
            backdrop-filter: blur(5px);
        }
        .action-btn:hover { 
            background: #fff; 
            transform: translateY(-1px); 
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
            border-color: #ddd;
        }
        .btn-cost { color: #e53935; font-size: 11px; margin-left: 4px; font-weight: 700; }

        /* 點數圖形樣式 */
        .dots-grid { width: 14px; height: 14px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px; }
        .dot-cell { display: flex; align-items: center; justify-content: center; }
        .dot { width: 2.5px; height: 2.5px; background: #333; border-radius: 50%; }
        .dot.red { background: #ff4d4d; }
        .dot.large { width: 5px; height: 5px; }

        /* 動畫 */
        .score-up { animation: bounce 0.5s; color: #4CAF50 !important; }
        .score-down { animation: shake 0.4s; color: #f44336 !important; }
        @keyframes bounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
        
        #instruction {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #777;
            font-size: 12px;
            background: rgba(255,255,255,0.85);
            padding: 6px 16px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            backdrop-filter: blur(4px);
        }

        #message-box {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(33, 33, 33, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 10px;
            display: none;
            z-index: 1000;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="left-ui">
        <div id="hud">
            <div id="score-label">積分</div>
            <div id="score-value">0</div>
        </div>

        <div id="dice-faces-strip">
            <!-- 骰子 1-6 點預覽圖 -->
            <div class="face-box"><div class="dots-grid"><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot red large"></div></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div></div></div>
            <div class="face-box"><div class="dots-grid"><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot"></div></div></div></div>
            <div class="face-box"><div class="dots-grid"><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot"></div></div></div></div>
            <div class="face-box"><div class="dots-grid"><div class="dot-cell"><div class="dot red"></div></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot red"></div></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot red"></div></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot red"></div></div></div></div>
            <div class="face-box"><div class="dots-grid"><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot"></div></div></div></div>
            <div class="face-box"><div class="dots-grid"><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"><div class="dot"></div></div><div class="dot-cell"></div><div class="dot-cell"><div class="dot"></div></div></div></div>
        </div>

        <div id="action-buttons">
            <button class="action-btn" onclick="randomUpgrade()">隨機升級 <span class="btn-cost">200</span></button>
            <button class="action-btn" onclick="randomDiceTeleport()">隨機傳送 <span class="btn-cost">500</span></button>
        </div>
    </div>

    <div id="message-box"></div>
    <div id="instruction"><b>[空白鍵]</b> 擲骰子 | <b>[滑鼠]</b> 旋轉視角 | <b>[點擊路徑]</b> 移動</div>

    <script>
        let scene, camera, renderer, dice, board;
        const diceSize = 0.56; 
        const gridSize = 19; 
        const cellSize = 1;
        const halfBoard = (gridSize - 1) / 2; 

        let isMoving = false;
        let totalScore = 0;
        let pathGroup = null; 

        let cameraAzimuth = 0; 
        let cameraPolar = 0.8; 
        let isMouseDown = false;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const materialIndexToPoint = { 0: 1, 1: 6, 2: 2, 3: 5, 4: 3, 5: 4 };

        const chipsConfig = [
            { val: 100, color: '#4CAF50' },
            { val: 200, color: '#2196F3' },
            { val: 300, color: '#9C27B0' },
            { val: 500, color: '#FFEB3B' },
            { val: 1000, color: '#F44336' }
        ];

        let collectibleChips = [];

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(10, 20, 10);
            light.castShadow = true;
            scene.add(light);

            createBoard();
            createChipsDecorations();
            createDice();
            updateCameraPosition();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => { if(e.code === 'Space') performToss(); });
            
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', () => isMouseDown = false);
            
            animate();
        }

        function createBoard() {
            const size = gridSize * cellSize;
            const geometry = new THREE.PlaneGeometry(size, size);
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff }); 
            board = new THREE.Mesh(geometry, material);
            board.rotation.x = -Math.PI / 2;
            board.receiveShadow = true;
            scene.add(board);
            
            const gridHelper = new THREE.GridHelper(size, gridSize, 0xe0e0e0, 0xf0f0f0);
            gridHelper.position.y = 0.005;
            scene.add(gridHelper);
        }

        function showMessage(text) {
            const box = document.getElementById('message-box');
            box.innerText = text;
            box.style.display = 'block';
            setTimeout(() => { box.style.display = 'none'; }, 2000);
        }

        function createChipsDecorations() {
            // 清除舊籌碼
            collectibleChips.forEach(c => scene.remove(c));
            collectibleChips = [];

            const occupiedCells = new Set();
            occupiedCells.add("0,0"); // 起點不放

            // 讓生成的數量更隨機一點
            const density = 0.1 + Math.random() * 0.15; // 10% - 25% 的覆蓋率
            const targetChipsCount = Math.floor(gridSize * gridSize * density);

            for (let i = 0; i < targetChipsCount; i++) {
                let rx, rz, key;
                let attempts = 0;
                do {
                    rx = Math.floor(Math.random() * gridSize) - halfBoard;
                    rz = Math.floor(Math.random() * gridSize) - halfBoard;
                    key = `${rx},${rz}`;
                    attempts++;
                } while (occupiedCells.has(key) && attempts < 50);

                if (attempts < 50) {
                    occupiedCells.add(key);
                    // 隨機選擇配置，越高等級出現機率越低
                    const rand = Math.random();
                    let config;
                    if (rand < 0.5) config = chipsConfig[0];      // 100
                    else if (rand < 0.75) config = chipsConfig[1]; // 200
                    else if (rand < 0.9) config = chipsConfig[2];  // 300
                    else if (rand < 0.98) config = chipsConfig[3]; // 500
                    else config = chipsConfig[4];                  // 1000

                    create3DChip(rx, rz, config);
                }
            }
        }

        function create3DChip(x, z, config) {
            const group = new THREE.Group();
            const chipGeom = new THREE.CylinderGeometry(0.35, 0.35, 0.08, 32);
            const chipMat = new THREE.MeshPhongMaterial({ color: config.color });
            const chipBody = new THREE.Mesh(chipGeom, chipMat);
            
            // 繪製文字貼圖
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = config.color; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.beginPath(); ctx.arc(64,64,52,0,Math.PI*2); ctx.fill();
            ctx.fillStyle = '#333'; ctx.font = 'bold 44px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(config.val.toString(), 64, 64);
            
            const textTex = new THREE.CanvasTexture(canvas);
            const topGeom = new THREE.CircleGeometry(0.32, 32);
            const topMat = new THREE.MeshBasicMaterial({ map: textTex, transparent: true });
            const topLabel = new THREE.Mesh(topGeom, topMat);
            topLabel.rotation.x = -Math.PI / 2; topLabel.position.y = 0.041;
            
            group.add(chipBody, topLabel);
            group.position.set(x, 0.04, z);
            // 籌碼隨機旋轉，看起來更自然一點
            group.rotation.y = Math.random() * Math.PI * 2;
            
            group.userData = { value: config.val, x: x, z: z };
            collectibleChips.push(group);
            scene.add(group);
        }

        function showPath(points) {
            if (pathGroup) scene.remove(pathGroup);
            pathGroup = new THREE.Group();
            const directions = [{n:'xp',x:1,z:0},{n:'xn',x:-1,z:0},{n:'zp',x:0,z:1},{n:'zn',x:0,z:-1}];
            
            // 調整後的顏色：螢光綠 (Fluorescent Green)
            const pathColor = 0xccff00; 

            directions.forEach(baseDir => {
                const pathData = calculatePath(dice.position, baseDir, points);
                pathData.forEach((step, i) => {
                    const geometry = new THREE.PlaneGeometry(0.92, 0.92);
                    const isTarget = (i === points && i > 0);
                    const material = new THREE.MeshBasicMaterial({
                        color: pathColor,
                        transparent: true, 
                        opacity: isTarget ? 0.4 : 0.15, // 低透明度
                        side: THREE.DoubleSide
                    });
                    const stepMesh = new THREE.Mesh(geometry, material);
                    stepMesh.rotation.x = -Math.PI / 2;
                    stepMesh.position.set(step.x, 0.012, step.z);
                    stepMesh.userData = { directionName: baseDir.n, isTarget: isTarget, fullPath: pathData };
                    pathGroup.add(stepMesh);
                });
            });
            scene.add(pathGroup);
        }

        function calculatePath(startPos, dir, points) {
            let path = [{ x: Math.round(startPos.x), z: Math.round(startPos.z) }];
            let curX = path[0].x, curZ = path[0].z, dx = dir.x, dz = dir.z;
            for (let i = 1; i <= points; i++) {
                let nx = curX + dx, nz = curZ + dz;
                if (nx > halfBoard || nx < -halfBoard) { dx = -dx; nx = curX + dx; }
                if (nz > halfBoard || nz < -halfBoard) { dz = -dz; nz = curZ + dz; }
                curX = nx; curZ = nz;
                path.push({ x: curX, z: curZ, dx, dz });
            }
            return path;
        }

        function onMouseDown(e) {
            isMouseDown = true;
            if (isMoving || !pathGroup) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            dice.visible = false;
            const intersects = raycaster.intersectObjects(pathGroup.children);
            dice.visible = true;
            if (intersects.length > 0) {
                const targetObj = intersects.find(intersect => intersect.object.userData.isTarget) || intersects[0];
                const finalTarget = pathGroup.children.find(child => child.userData.directionName === targetObj.object.userData.directionName && child.userData.isTarget);
                if (finalTarget) rollDiceAlongPath(finalTarget.userData.fullPath);
            }
        }

        function onMouseMove(e) {
            if (isMouseDown) {
                cameraAzimuth -= e.movementX * 0.005;
                cameraPolar += e.movementY * 0.005;
                cameraPolar = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraPolar));
            }
            if (isMoving || !pathGroup) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            dice.visible = false;
            const intersects = raycaster.intersectObjects(pathGroup.children);
            dice.visible = true;

            pathGroup.children.forEach(child => child.material.opacity = child.userData.isTarget ? 0.4 : 0.15);

            if (intersects.length > 0) {
                const dirName = intersects[0].object.userData.directionName;
                pathGroup.children.forEach(child => {
                    if (child.userData.directionName === dirName) {
                        child.material.opacity = child