<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Dice Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/RoundedBoxGeometry.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        #left-ui {
            position: absolute;
            top: 15px; 
            left: 15px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 6px; 
            pointer-events: none;
            transform-origin: top left;
            transform: scale(0.9); 
        }

        /* Top Battle UI */
        #top-ui {
            position: absolute;
            top: 10px; 
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 80%;
            pointer-events: none;
        }

        #health-bar-container {
            display: flex;
            gap: 2px;
            background: rgba(0,0,0,0.6);
            padding: 4px;
            border-radius: 4px;
            border: 1px solid rgba(255, 50, 50, 0.3);
        }

        .health-segment {
            width: 20px; 
            height: 20px;
            background-color: #F44336; 
            border-radius: 2px;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 0 5px #F44336;
        }
        .health-lost { 
            background-color: #333; 
            box-shadow: none;
            transform: scale(0.9);
        }

        #boss-counter-panel {
            background: rgba(0, 30, 80, 0.85);
            color: #00d0ff;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 12px;
            border: 1px solid #00d0ff;
            text-shadow: 0 0 5px #00d0ff;
            margin-top: 2px;
        }

        #boss-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: auto;
            background: #000000;
            color: #ff3333;
            border: 2px solid #ff3333;
            padding: 8px 16px;
            font-size: 16px;
            font-weight: 900;
            cursor: pointer;
            display: none;
            z-index: 100;
            border-radius: 8px;
            text-shadow: 0 0 5px #ff0000;
            box-shadow: 0 0 15px rgba(0,0,0,0.6);
            letter-spacing: 2px;
            transition: all 0.3s;
            animation: pulse-red 2s infinite;
        }
        #boss-btn:hover { transform: scale(1.1); background: #222; }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.4); }
            50% { box-shadow: 0 0 25px rgba(255, 0, 0, 0.8); }
            100% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.4); }
        }

        #hud {
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 12px; 
            border-radius: 8px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.06);
            pointer-events: auto;
            display: flex;
            align-items: baseline;
            gap: 8px;
            border: 1px solid rgba(0,0,0,0.05);
        }

        #score-label { font-size: 12px; font-weight: 600; color: #4CAF50; }
        #score-value { font-size: 18px; font-weight: 800; color: #4CAF50; min-width: 30px; }

        #dice-status-panel {
            background: rgba(255, 255, 255, 0.85);
            padding: 8px; 
            border-radius: 8px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            pointer-events: auto;
            border: 1px solid rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
        }
        
        #dice-faces-preview { 
            display: grid; 
            grid-template-columns: repeat(3, 34px); 
            grid-template-rows: repeat(2, 34px);
            gap: 4px; 
        }
        .face-box { 
            width: 34px; 
            height: 34px; 
            border: 1px solid #eee; 
            border-radius: 4px; 
            background: white; 
            background-size: cover;
            opacity: 0.9;
            transition: all 0.2s;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            overflow: hidden;
            cursor: default;
        }
        
        .upgrade-text {
            font-size: 7px; 
            color: #fff;
            background: rgba(0,0,0,0.6);
            width: 100%;
            text-align: center;
            padding: 1px 0;
            font-weight: bold;
            display: block; 
            line-height: 1;
        }

        .face-can-upgrade {
            cursor: pointer;
            box-shadow: 0 0 8px #FFEB3B; 
            border: 2px solid #FFEB3B;     
            animation: pulse-yellow 1.5s infinite;
            transform: scale(1.05);
            z-index: 5;
        }
        .face-can-upgrade:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px #FFEB3B;
        }

        @keyframes pulse-yellow {
            0% { box-shadow: 0 0 3px #FFEB3B; }
            50% { box-shadow: 0 0 10px #FFEB3B; }
            100% { box-shadow: 0 0 3px #FFEB3B; }
        }

        .face-upgraded { transform: scale(1.2) !important; border-color: #ffeb3b !important; box-shadow: 0 0 10px #ffeb3b !important; z-index: 10; }
        .face-downgraded { transform: scale(0.9) !important; border-color: #F44336 !important; box-shadow: 0 0 10px #F44336 !important; filter: grayscale(100%); }

        #action-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
            pointer-events: auto;
            width: 100%;
            margin-bottom: 2px; 
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid #eee;
            padding: 6px 10px; 
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px; 
            font-weight: 600;
            color: #444;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.03);
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 116px; 
        }
        .action-btn:hover { background: #fff; transform: translateY(-1px); }
        .btn-cost { color: #000000; font-size: 10px; font-weight: 700; opacity: 0.7; }

        #instruction {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 11px;
            background: rgba(255,255,255,0.8);
            padding: 5px 14px;
            border-radius: 15px;
            backdrop-filter: blur(4px);
            text-align: center;
        }

        #message-box {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            display: none;
            z-index: 1000;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            pointer-events: none;
            width: max-content;
        }

        #end-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        #end-title { font-size: 48px; font-weight: 900; margin-bottom: 20px; letter-spacing: 5px; }
        #end-stats { font-size: 24px; margin-bottom: 20px; color: #aaa; }
        #end-dice-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px;
        }
        #end-dice-label {
            font-size: 14px;
            margin-bottom: 10px;
            color: #ddd;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #end-dice-preview {
            display: grid;
            grid-template-columns: repeat(3, 50px);
            grid-template-rows: repeat(2, 50px);
            gap: 10px;
        }
        .end-face-box {
            width: 50px;
            height: 50px;
            background: white;
            background-size: cover;
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(255,255,255,0.2);
        }

        #restart-btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        #restart-btn:hover { transform: scale(1.1); }

        .score-up { animation: bounce 0.5s; color: #4CAF50 !important; }
        .score-down { animation: shake 0.4s; color: #4CAF50 !important; }
        @keyframes bounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
    </style>
</head>
<body>
    <div id="top-ui">
        <div id="health-bar-container" style="display:none;">
            <!-- JS will inject segments here -->
        </div>
        <div id="boss-counter-panel" style="display:none;">
            BOSS ACTION IN: <span id="boss-moves-left">-</span>
        </div>
    </div>

    <div id="left-ui">
        <div id="hud">
            <div id="score-label">Score</div>
            <div id="score-value">0</div>
        </div>
        <div id="action-buttons">
            <button class="action-btn" onclick="randomDiceTeleport()">
                <span>TELEPORT</span> <span class="btn-cost">500</span>
            </button>
        </div>
        <div id="dice-status-panel">
            <div id="dice-faces-preview">
                <div class="face-box" id="f-0" onclick="tryUpgradeFace(0)"><span class="upgrade-text">UP 100</span></div>
                <div class="face-box" id="f-1" onclick="tryUpgradeFace(1)"><span class="upgrade-text">UP 100</span></div>
                <div class="face-box" id="f-2" onclick="tryUpgradeFace(2)"><span class="upgrade-text">UP 100</span></div>
                <div class="face-box" id="f-3" onclick="tryUpgradeFace(3)"><span class="upgrade-text">UP 100</span></div>
                <div class="face-box" id="f-4" onclick="tryUpgradeFace(4)"><span class="upgrade-text">UP 100</span></div>
                <div class="face-box" id="f-5" onclick="tryUpgradeFace(5)"><span class="upgrade-text">UP 100</span></div>
            </div>
        </div>
    </div>
    
    <button id="boss-btn" onclick="triggerBoss()">BOSS</button>

    <div id="message-box"></div>
    <div id="instruction">
        <b>[SPACE]</b> Roll | <b>[CLICK]</b> Move | Clear Beams to Win
    </div>

    <div id="end-screen">
        <div id="end-title">GAME OVER</div>
        <div id="end-dice-container">
            <div id="end-dice-label">Final Dice State</div>
            <div id="end-dice-preview">
                <!-- JS will populate this -->
            </div>
        </div>
        <div id="end-stats">Total Rolls: <span id="total-tosses-val">0</span></div>
        <button id="restart-btn" onclick="location.reload()">RETRY</button>
    </div>

    <script>
        let scene, camera, renderer, dice, board;
        let bossDice = null;
        let beams = []; 
        let particles = []; 
        
        let bossActive = false;
        let playerMovesSinceBoss = 0;
        let bossLastRoll = 4; 
        let nextBossThreshold = 6; 
        let bossHP = 12; 
        const MAX_HP = 12; 
        let totalTosses = 0;
        let totalPlayerMoves = 0; 

        const diceSize = 0.56; 
        const gridSize = 19; 
        const cellSize = 1;
        const halfBoard = (gridSize - 1) / 2; 
        const bossFloatHeight = 1.0; 

        let isMoving = false;
        let hasMovedSinceLastToss = true; 
        let totalScore = 100; 
        let pathGroup = null; 
        let cameraAzimuth = 0; 
        let cameraPolar = 0.8; 
        let isMouseDown = false;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let diceFacePoints = [1, 1, 1, 2, 2, 2]; 

        const chipsConfig = [
            { val: 50, color: '#4CAF50' },
            { val: 100, color: '#2196F3' },
            { val: 150, color: '#FFD700' }
        ];

        let collectibleObjects = []; 
        const PATH_COLOR = 0x00FF00; 
        const OPACITY_NORMAL = 0.05;
        const OPACITY_TARGET = 0.15;
        const OPACITY_HOVER_NORMAL = 0.12;
        const OPACITY_HOVER_TARGET = 0.35;
        const occupiedLocations = new Map(); 

        function init() {
            initHealthBar();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(10, 20, 10);
            light.castShadow = true;
            scene.add(light);

            createBoard();
            createMapContent();
            createDice();
            updateDiceUI();
            updateCameraPosition();
            updateScoreUI();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => { if(e.code === 'Space') performToss(); });
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', () => isMouseDown = false);
            animate();
        }

        function initHealthBar() {
            const container = document.getElementById('health-bar-container');
            container.innerHTML = '';
            for (let i = 0; i < MAX_HP; i++) {
                const seg = document.createElement('div');
                seg.className = 'health-segment';
                seg.id = `hp-${i}`;
                container.appendChild(seg);
            }
        }

        function updateHealthUI() {
            for (let i = 0; i < MAX_HP; i++) {
                const seg = document.getElementById(`hp-${i}`);
                if (i < bossHP) {
                    seg.classList.remove('health-lost');
                } else {
                    seg.classList.add('health-lost');
                }
            }
        }

        function updateBossCounter() {
            const el = document.getElementById('boss-moves-left');
            nextBossThreshold = 2 + bossLastRoll; 
            const movesLeft = Math.max(0, nextBossThreshold - playerMovesSinceBoss);
            el.innerText = movesLeft;
        }

        function updateDiceUI(highlightIndex = -1, downgradeIndex = -1) {
            diceFacePoints.forEach((pts, i) => {
                const el = document.getElementById(`f-${i}`);
                if (!el) return;
                const canvas = generatePointCanvas(pts);
                el.style.backgroundImage = `url(${canvas.toDataURL()})`;
                
                el.classList.remove('face-upgraded', 'face-downgraded', 'face-can-upgrade');

                // Glow condition: score >= 100 AND face < 6 AND ready to roll (hasMovedSinceLastToss) AND not moving
                if (totalScore >= 100 && pts < 6 && hasMovedSinceLastToss && !isMoving) {
                    el.classList.add('face-can-upgrade');
                }

                if (i === highlightIndex) {
                    el.classList.add('face-upgraded');
                    setTimeout(() => el.classList.remove('face-upgraded'), 600);
                }
                
                if (i === downgradeIndex) {
                    el.classList.add('face-downgraded');
                    setTimeout(() => el.classList.remove('face-downgraded'), 600);
                }
            });
        }

        function tryUpgradeFace(index) {
            if (isMoving) return;
            
            // Requirement: "路徑已經生成，玩家卻按下升級按鍵時顯示白色的 'Move First!'"
            // Path is generated when hasMovedSinceLastToss is false.
            if (!hasMovedSinceLastToss) {
                showMessage("Move First!", "white");
                return;
            }

            if (totalScore < 100) return;
            if (diceFacePoints[index] >= 6) {
                showMessage("MAX LEVEL!", "#F44336");
                return; 
            }

            subtractScore(100);
            diceFacePoints[index]++;
            
            const newTex = new THREE.CanvasTexture(generatePointCanvas(diceFacePoints[index]));
            dice.material[index].map = newTex;
            dice.material[index].needsUpdate = true;
            
            flashDice();
            updateDiceUI(index);
            // Requirement: "升級時只顯示 'Upgrade!'"
            showMessage("Upgrade!", "#ffeb3b");
            checkBossUnlock();
        }

        function downgradeRandomFace() {
            let eligibleIndices = [];
            diceFacePoints.forEach((pts, i) => { if(pts > 1) eligibleIndices.push(i); });
            
            if (eligibleIndices.length > 0) {
                const targetIdx = eligibleIndices[Math.floor(Math.random() * eligibleIndices.length)];
                diceFacePoints[targetIdx]--;
                
                const newTex = new THREE.CanvasTexture(generatePointCanvas(diceFacePoints[targetIdx]));
                dice.material[targetIdx].map = newTex;
                dice.material[targetIdx].needsUpdate = true;
                
                updateDiceUI(-1, targetIdx);
                showMessage(`Face Downgraded!`, "#F44336");
            } else {
                showMessage("All faces at minimum!", "#F44336");
            }
        }

        function checkBossUnlock() {
            if (bossActive) return;
            const btn = document.getElementById('boss-btn');
            if (totalTosses >= 25 && btn.style.display !== 'block') {
                btn.style.display = 'block';
                showMessage("WARNING: BOSS AVAILABLE!", "#ff0000");
            }
        }

        function triggerBoss() {
            const btn = document.getElementById('boss-btn');
            btn.style.display = 'none';
            bossActive = true;
            playerMovesSinceBoss = 0;
            document.getElementById('boss-counter-panel').style.display = 'block';
            document.getElementById('health-bar-container').style.display = 'flex';
            updateBossCounter();
            updateHealthUI();
            scene.background = new THREE.Color(0x2d1b4e);

            const enemiesToRemove = collectibleObjects.filter(obj => obj.userData.type === 'enemy');
            enemiesToRemove.forEach(enemy => {
                const x = enemy.userData.x;
                const z = enemy.userData.z;
                const startScaleY = enemy.scale.y;
                let squashFrame = 0;
                const squashDuration = 20;

                function animateSquash() {
                    squashFrame++;
                    const progress = squashFrame / squashDuration;
                    if (progress < 1) {
                        enemy.scale.y = startScaleY * (1 - progress);
                        enemy.position.y = (0.45 * enemy.scale.y) / 2;
                        requestAnimationFrame(animateSquash);
                    } else {
                        scene.remove(enemy);
                        occupiedLocations.delete(`${x},${z}`);
                        create3DChip(x, z, { val: 50, color: '#4CAF50' });
                        occupiedLocations.set(`${x},${z}`, 'chip');
                    }
                }
                animateSquash();
            });
            collectibleObjects = collectibleObjects.filter(obj => obj.userData.type !== 'enemy');

            const bossSize = diceSize * 2.4; 
            const geometry = new THREE.RoundedBoxGeometry(bossSize, bossSize, bossSize, 4, 0.2);
            const materials = [];
            for(let i=1; i<=6; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000000'; ctx.fillRect(0,0,256,256);
                ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 10; ctx.strokeRect(0,0,256,256);
                ctx.fillStyle = '#ffffff';
                const radius = 24; 
                const posMap = {
                    1: [[128, 128]], 2: [[70, 70], [186, 186]], 3: [[60, 60], [128, 128], [196, 196]],
                    4: [[75, 75], [181, 75], [75, 181], [181, 181]], 5: [[75, 75], [181, 75], [128, 128], [75, 181], [181, 181]],
                    6: [[75, 60], [75, 128], [75, 196], [181, 60], [181, 128], [181, 196]]
                };
                (posMap[i] || []).forEach(p => { ctx.beginPath(); ctx.arc(p[0], p[1], radius, 0, Math.PI * 2); ctx.fill(); });
                materials.push(new THREE.MeshPhongMaterial({ map: new THREE.CanvasTexture(canvas), emissive: new THREE.Color(0x330000) }));
            }
            bossDice = new THREE.Mesh(geometry, materials);
            bossDice.position.set(0, 20, 0); 
            bossDice.castShadow = true;
            scene.add(bossDice);

            let velocity = 0;
            const gravity = 0.02;
            const groundY = bossSize / 2 + bossFloatHeight; 
            function animateBossDrop() {
                velocity += gravity;
                bossDice.position.y -= velocity;
                bossDice.rotation.x += 0.05;
                bossDice.rotation.z += 0.02;
                if (bossDice.position.y <= groundY) {
                    bossDice.position.y = groundY;
                    bossDice.rotation.set(0, 0, 0); 
                    camera.position.y -= 0.5;
                    setTimeout(() => camera.position.y += 0.5, 50);
                    setTimeout(() => bossTurn(), 500); 
                    return; 
                }
                requestAnimationFrame(animateBossDrop);
            }
            animateBossDrop();
        }

        async function bossTurn() {
            if (bossHP <= 0) return; 
            isMoving = true; 
            const bossSize = diceSize * 2.4; 
            const floatY = bossSize / 2 + bossFloatHeight;
            const duration = 50; 
            let frame = 0;
            const startQuat = bossDice.quaternion.clone();
            const axis = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            const totalRot = Math.PI * 6 + Math.random() * Math.PI * 4;
            const curX = bossDice.position.x; 
            const curZ = bossDice.position.z;

            await new Promise(resolve => {
                function animateBossToss() {
                    frame++; 
                    const t = frame / duration;
                    if (frame <= duration) {
                        bossDice.position.y = floatY + Math.sin(t * Math.PI) * 8;
                        const currentRot = new THREE.Quaternion().setFromAxisAngle(axis, totalRot * t);
                        bossDice.quaternion.copy(startQuat).premultiply(currentRot);
                        requestAnimationFrame(animateBossToss);
                    } else {
                        bossDice.position.set(curX, floatY, curZ);
                        const euler = new THREE.Euler().setFromQuaternion(bossDice.quaternion);
                        euler.x = Math.round(euler.x / (Math.PI / 2)) * (Math.PI / 2);
                        euler.y = Math.round(euler.y / (Math.PI / 2)) * (Math.PI / 2);
                        euler.z = Math.round(euler.z / (Math.PI / 2)) * (Math.PI / 2);
                        bossDice.quaternion.setFromEuler(euler);
                        resolve();
                    }
                }
                animateBossToss();
            });
            bossLastRoll = Math.floor(Math.random() * 6) + 1; 
            spawnBeams(bossLastRoll);
            playerMovesSinceBoss = 0;
            updateBossCounter(); 
            isMoving = false; 
        }

        function spawnBeams(count) {
            for(let i=0; i<count; i++) {
                let bx, bz;
                let attempts = 0;
                do {
                    bx = Math.floor(Math.random() * gridSize) - halfBoard;
                    bz = Math.floor(Math.random() * gridSize) - halfBoard;
                    attempts++;
                } while (
                    (bx === 0 && bz === 0) || 
                    (bx === Math.round(dice.position.x) && bz === Math.round(dice.position.z)) 
                    && attempts < 50
                );
                const existing = beams.find(b => b.userData.x === bx && b.userData.z === bz);
                if (!existing) {
                    const h = 10;
                    const geo = new THREE.CylinderGeometry(0.4, 0.4, h, 16);
                    const mat = new THREE.MeshPhongMaterial({
                        color: 0x2a003b, emissive: 0xaa00ff, emissiveIntensity: 0.8, transparent: true, opacity: 0.4 
                    });
                    const beam = new THREE.Mesh(geo, mat);
                    beam.position.set(bx, h/2, bz);
                    beam.userData = { x: bx, z: bz, type: 'beam' };
                    scene.add(beam);
                    beams.push(beam);
                }
            }
            if (beams.length >= 21) gameOver(false, "OVERLOAD!");
        }

        async function checkBeamCollision(x, z) {
            const index = beams.findIndex(b => b.userData.x === Math.round(x) && b.userData.z === Math.round(z));
            if (index !== -1) {
                const beam = beams[index];
                scene.remove(beam);
                beams.splice(index, 1);
                bossHP--;
                updateHealthUI();
                if (bossHP <= 0) { await animateBossDefeat(); return true; }
            }
            return false;
        }

        async function animateBossDefeat() {
            isMoving = true; 
            const startY = bossDice.position.y, startX = bossDice.position.x, startZ = bossDice.position.z;
            const duration = 120; 
            for(let i=0; i<50; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshBasicMaterial({color:0xffffff}));
                p.position.set(startX, startY, startZ);
                p.userData.vel = new THREE.Vector3((Math.random()-0.5)*1.5, (Math.random()-0.5)*1.5, (Math.random()-0.5)*1.5);
                scene.add(p);
                particles.push(p);
            }
            for(let f=0; f<duration; f++) {
                const t = f/duration;
                const scale = 1 + t * 4;
                bossDice.scale.set(scale, scale, scale);
                bossDice.position.set(startX+(Math.random()-0.5)*0.5, startY+(Math.random()-0.5)*0.5, startZ+(Math.random()-0.5)*0.5);
                bossDice.material.forEach(m => {
                    m.emissive.setRGB(1, 1-(f%5)*0.2, 1-(f%5)*0.2);
                    m.emissiveIntensity = 1 + t * 5;
                    m.transparent = true; m.opacity = 0.7;
                });
                if (t > 0.5) {
                    particles.forEach(p => { p.position.add(p.userData.vel); p.rotation.x += 0.2; p.rotation.y += 0.2; });
                }
                await new Promise(requestAnimationFrame);
            }
            scene.remove(bossDice);
            particles.forEach(p => scene.remove(p));
            particles = [];
            await new Promise(r => setTimeout(r, 2000));
            gameOver(true, "VICTORY!");
        }

        function gameOver(win, msg) {
            isMoving = true; 
            document.getElementById('end-screen').style.display = 'flex';
            document.getElementById('end-title').innerText = win ? "CONGRATULATION" : "GAME OVER";
            document.getElementById('end-title').style.color = win ? "#4CAF50" : "#F44336";
            document.getElementById('total-tosses-val').innerText = totalTosses;
            const previewContainer = document.getElementById('end-dice-preview');
            previewContainer.innerHTML = '';
            diceFacePoints.forEach(pts => {
                const div = document.createElement('div');
                div.className = 'end-face-box';
                div.style.backgroundImage = `url(${generatePointCanvas(pts).toDataURL()})`;
                previewContainer.appendChild(div);
            });
        }

        function createBoard() {
            const size = gridSize * cellSize;
            board = new THREE.Mesh(new THREE.PlaneGeometry(size, size), new THREE.MeshPhongMaterial({ color: 0xffffff }));
            board.rotation.x = -Math.PI / 2; board.receiveShadow = true;
            scene.add(board);
            const gridHelper = new THREE.GridHelper(size, gridSize, 0xb0b0b0, 0xc0c0c0);
            gridHelper.position.y = 0.001; scene.add(gridHelper);
        }

        function showMessage(text, color = "white") {
            const box = document.getElementById('message-box');
            box.innerText = text; box.style.color = color; box.style.display = 'block';
            setTimeout(() => { box.style.display = 'none'; }, 2500);
        }

        function countSurroundingChips(x, z) {
            let count = 0;
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    if (dx === 0 && dz === 0) continue;
                    if (occupiedLocations.get(`${x + dx},${z + dz}`) === 'chip') count++;
                }
            }
            return count;
        }

        function hasSurroundingEnemy(x, z) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    if (dx === 0 && dz === 0) continue;
                    if (occupiedLocations.get(`${x + dx},${z + dz}`) === 'enemy') return true;
                }
            }
            return false;
        }

        function createMapContent() {
            collectibleObjects.forEach(c => scene.remove(c));
            collectibleObjects = []; occupiedLocations.clear();
            const possiblePositions = [];
            for (let x = -halfBoard; x <= halfBoard; x++) {
                for (let z = -halfBoard; z <= halfBoard; z++) {
                    if (x === 0 && z === 0) continue; possiblePositions.push({x, z});
                }
            }
            for (let i = possiblePositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [possiblePositions[i], possiblePositions[j]] = [possiblePositions[j], possiblePositions[i]];
            }
            let cC = 0, eC = 0;
            const weights = [6, 3, 2]; const tW = 11;
            for (let pos of possiblePositions) {
                const rand = Math.random();
                if (eC < Math.floor(gridSize*gridSize*0.08) && rand < 0.15 && !hasSurroundingEnemy(pos.x, pos.z)) {
                    create3DEnemy(pos.x, pos.z); occupiedLocations.set(`${pos.x},${pos.z}`, 'enemy'); eC++; continue;
                } 
                if (cC < Math.floor(gridSize*gridSize*0.18) && rand < 0.25 && !occupiedLocations.has(`${pos.x},${pos.z}`) && countSurroundingChips(pos.x, pos.z) < 2) {
                    const r = Math.random() * tW; let idx = 0, acc = 0;
                    for(let i=0; i<3; i++){ acc += weights[i]; if(r<acc){ idx=i; break; } }
                    create3DChip(pos.x, pos.z, chipsConfig[idx]); occupiedLocations.set(`${pos.x},${pos.z}`, 'chip'); cC++;
                }
            }
        }

        function create3DChip(x, z, config) {
            const group = new THREE.Group();
            group.add(new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.08, 32), new THREE.MeshPhongMaterial({ color: config.color, transparent: true, opacity: 0.95 })));
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = config.color; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.beginPath(); ctx.arc(64,64,52,0,Math.PI*2); ctx.fill();
            ctx.fillStyle = '#111'; ctx.font = 'bold 42px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(config.val.toString(), 64, 64);
            const top = new THREE.Mesh(new THREE.CircleGeometry(0.32, 32), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            top.rotation.x = -Math.PI / 2; top.position.y = 0.041; group.add(top);
            group.position.set(x, 0.04, z); group.userData = { type: 'chip', value: config.val, x: x, z: z };
            collectibleObjects.push(group); scene.add(group);
        }

        function create3DEnemy(x, z) {
            const pts = Math.floor(Math.random() * 5) + 1; const sz = 0.45;
            const mats = [];
            for(let i=0; i<6; i++) {
                const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d'); ctx.fillStyle = '#F44336'; ctx.fillRect(0, 0, 128, 128);
                ctx.fillStyle = 'white';
                const posMap = {1:[[64,64]],2:[[35,35],[93,93]],3:[[30,30],[64,64],[98,98]],4:[[38,38],[90,38],[38,90],[90,90]],5:[[38,38],[90,38],[64,64],[38,90],[90,90]],6:[[38,30],[38,64],[38,98],[90,30],[90,64],[90,98]]};
                (posMap[pts] || []).forEach(p => { ctx.beginPath(); ctx.arc(p[0], p[1], 18, 0, Math.PI*2); ctx.fill(); });
                mats.push(new THREE.MeshPhongMaterial({ map: new THREE.CanvasTexture(canvas) }));
            }
            const mesh = new THREE.Mesh(new THREE.RoundedBoxGeometry(sz, sz, sz, 2, 0.05), mats);
            mesh.position.set(x, sz/2, z); mesh.userData = { type: 'enemy', points: pts, x: x, z: z };
            collectibleObjects.push(mesh); scene.add(mesh);
        }

        function showPath(points) {
            if (pathGroup) scene.remove(pathGroup);
            pathGroup = new THREE.Group();
            [{n:'xp',x:1,z:0},{n:'xn',x:-1,z:0},{n:'zp',x:0,z:1},{n:'zn',x:0,z:-1}].forEach(base => {
                const pD = calculatePath(dice.position, base, points);
                pD.forEach((step, i) => {
                    const isT = (i === points && i > 0);
                    const mesh = new THREE.Mesh(new THREE.PlaneGeometry(0.95, 0.95), new THREE.MeshBasicMaterial({ color: PATH_COLOR, transparent: true, opacity: isT ? OPACITY_TARGET : OPACITY_NORMAL, side: THREE.DoubleSide, depthWrite: false }));
                    mesh.rotation.x = -Math.PI / 2; mesh.position.set(step.x, 0.003, step.z);
                    mesh.userData = { directionName: base.n, isTarget: isT, fullPath: pD };
                    pathGroup.add(mesh);
                });
            });
            scene.add(pathGroup);
        }

        function calculatePath(start, dir, points) {
            let path = [{ x: Math.round(start.x), z: Math.round(start.z) }];
            let cX = path[0].x, cZ = path[0].z, dX = dir.x, dZ = dir.z;
            for (let i = 1; i <= points; i++) {
                let nX = cX + dX, nZ = cZ + dZ;
                if (nX > halfBoard || nX < -halfBoard) { dX = -dX; nX = cX + dX; }
                if (nZ > halfBoard || nZ < -halfBoard) { dZ = -dZ; nZ = cZ + dZ; }
                cX = nX; cZ = nZ; path.push({ x: cX, z: cZ, dX, dZ });
            }
            return path;
        }

        function onMouseDown(e) {
            isMouseDown = true;
            if (isMoving || !pathGroup) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            dice.visible = false; const int = raycaster.intersectObjects(pathGroup.children); dice.visible = true;
            if (int.length > 0) {
                const targetObj = int.find(i => i.object.userData.isTarget) || int[0];
                const final = pathGroup.children.find(c => c.userData.directionName === targetObj.object.userData.directionName && c.userData.isTarget);
                if (final) rollDiceAlongPath(final.userData.fullPath);
            }
        }

        function onMouseMove(e) {
            if (isMouseDown) { cameraAzimuth -= e.movementX * 0.005; cameraPolar = Math.max(0.1, Math.min(Math.PI/2-0.1, cameraPolar + e.movementY * 0.005)); }
            if (isMoving || !pathGroup) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera); dice.visible = false; const int = raycaster.intersectObjects(pathGroup.children); dice.visible = true;
            pathGroup.children.forEach(c => c.material.opacity = c.userData.isTarget ? OPACITY_TARGET : OPACITY_NORMAL);
            if (int.length > 0) {
                const dN = int[0].object.userData.directionName;
                pathGroup.children.forEach(c => { if (c.userData.directionName === dN) c.material.opacity = c.userData.isTarget ? OPACITY_HOVER_TARGET : OPACITY_HOVER_NORMAL; });
            }
        }

        async function rollDiceAlongPath(path) {
            isMoving = true; if (pathGroup) { scene.remove(pathGroup); pathGroup = null; }
            totalPlayerMoves++;
            for (let s = 1; s < path.length; s++) {
                const step = path[s], prev = path[s-1], enemy = getObjectAt(step.x, step.z, 'enemy');
                if (await checkBeamCollision(step.x, step.z)) return; 
                if (enemy) {
                    showMessage("FIGHT!", "#ff4d4d"); await combatTossAnimation(enemy);
                    if (getUpwardFace() >= enemy.userData.points) {
                        addScore(100); await performCrushMove(prev, step, enemy);
                        scene.remove(enemy); collectibleObjects = collectibleObjects.filter(o => o !== enemy);
                        occupiedLocations.delete(`${enemy.userData.x},${enemy.userData.z}`); checkChipCollection(step.x, step.z);
                    } else {
                        // Combat failed: Deduct score or downgrade
                        if (totalScore - 50 < 0) { totalScore = 0; updateScoreUI(); downgradeRandomFace(); }
                        else { subtractScore(50); showMessage(`Smaller!`, "#F44336"); }
                        
                        // Requirement: "與小敵人戰鬥失敗時被擋下來時可以升級，左上角展開面要發光"
                        // Setting this to true allows upgrade status and glows.
                        hasMovedSinceLastToss = true; 
                        
                        if(bossActive) { 
                            playerMovesSinceBoss++; updateBossCounter(); 
                            if(playerMovesSinceBoss >= nextBossThreshold || beams.length === 0) { isMoving = false; await bossTurn(); }
                        }
                        isMoving = false;
                        updateDiceUI(); // Trigger glow
                        return;
                    }
                } else { await performSingleMove(prev, step); checkChipCollection(step.x, step.z); }
            }
            hasMovedSinceLastToss = true; isMoving = false; updateDiceUI();
            if (bossActive) { playerMovesSinceBoss++; updateBossCounter(); if (playerMovesSinceBoss >= nextBossThreshold || beams.length === 0) await bossTurn(); }
        }

        async function performCrushMove(from, to, enemy) {
            const rotA = new THREE.Vector3(to.z-from.z, 0, -(to.x-from.x)).normalize();
            const sP = dice.position.clone(), sQ = dice.quaternion.clone(), tP = new THREE.Vector3(to.x, diceSize/2, to.z);
            for (let f = 1; f <= 15; f++) {
                const t = f / 15; dice.position.lerpVectors(sP, tP, t); dice.position.y = (diceSize/2) + Math.sin(t*Math.PI)*1.2;
                dice.quaternion.copy(sQ).premultiply(new THREE.Quaternion().setFromAxisAngle(rotA, (Math.PI/2)*t));
                if (t > 0.6) { enemy.scale.y = 1 - ((t-0.6)/0.4)*0.9; enemy.position.y = (0.45*enemy.scale.y)/2; }
                await new Promise(requestAnimationFrame);
            }
            dice.position.copy(tP); snapDiceRotation();
        }

        async function performSingleMove(from, to) {
            const rotA = new THREE.Vector3(to.z-from.z, 0, -(to.x-from.x)).normalize();
            const sP = dice.position.clone(), sQ = dice.quaternion.clone(), tP = new THREE.Vector3(to.x, diceSize/2, to.z);
            for (let f = 1; f <= 8; f++) {
                const t = f / 8; dice.position.lerpVectors(sP, tP, t); dice.position.y = (diceSize/2) + Math.sin(t*Math.PI)*0.2;
                dice.quaternion.copy(sQ).premultiply(new THREE.Quaternion().setFromAxisAngle(rotA, (Math.PI/2)*t));
                await new Promise(requestAnimationFrame);
            }
            dice.position.copy(tP); snapDiceRotation();
        }

        async function combatTossAnimation(enemy) {
            const axis = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            const sQ = dice.quaternion.clone(), sY = dice.position.y, eY = enemy.position.y;
            for (let f = 1; f <= 30; f++) {
                const t = f/30; dice.position.y = sY + Math.sin(t*Math.PI)*1.8;
                dice.quaternion.copy(sQ).premultiply(new THREE.Quaternion().setFromAxisAngle(axis, Math.PI*6*t));
                enemy.position.y = eY + Math.sin(t*Math.PI)*1.2; await new Promise(requestAnimationFrame);
            }
            dice.position.y = diceSize / 2; enemy.position.y = 0.45 / 2; snapDiceRotation();
            await new Promise(r => setTimeout(r, 600)); 
        }

        function getObjectAt(x, z, type) { return collectibleObjects.find(o => Math.round(o.userData.x) === Math.round(x) && Math.round(o.userData.z) === Math.round(z) && o.userData.type === type); }

        function checkChipCollection(x, z) {
            const chip = getObjectAt(x, z, 'chip');
            if (chip) { addScore(chip.userData.value); scene.remove(chip); collectibleObjects = collectibleObjects.filter(o => o !== chip); occupiedLocations.delete(`${chip.userData.x},${chip.userData.z}`); }
        }

        function updateScoreUI() { document.getElementById('score-value').innerText = totalScore.toLocaleString(); updateDiceUI(); }

        function addScore(p) { totalScore += p; updateScoreUI(); const el = document.getElementById('score-value'); el.classList.remove('score-up'); void el.offsetWidth; el.classList.add('score-up'); }

        function subtractScore(p) { totalScore = Math.max(0, totalScore - p); updateScoreUI(); const el = document.getElementById('score-value'); el.classList.remove('score-down'); void el.offsetWidth; el.classList.add('score-down'); }

        function snapDiceRotation() {
            const e = new THREE.Euler().setFromQuaternion(dice.quaternion);
            e.x = Math.round(e.x/(Math.PI/2))*(Math.PI/2); e.y = Math.round(e.y/(Math.PI/2))*(Math.PI/2); e.z = Math.round(e.z/(Math.PI/2))*(Math.PI/2);
            dice.quaternion.setFromEuler(e);
        }

        function getUpwardFace() {
            const v = new THREE.Vector3(0, 1, 0).applyQuaternion(dice.quaternion.clone().invert());
            let max = -1, idx = -1;
            [new THREE.Vector3(1,0,0),new THREE.Vector3(-1,0,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,-1,0),new THREE.Vector3(0,0,1),new THREE.Vector3(0,0,-1)].forEach((fv, i) => { const d = fv.dot(v); if (d > max) { max = d; idx = i; } });
            return diceFacePoints[idx];
        }

        function performToss() {
            if(isMoving) return; if (!hasMovedSinceLastToss) { showMessage("Move First!"); return; }
            isMoving = true; if (pathGroup) { scene.remove(pathGroup); pathGroup = null; }
            totalTosses++; const sQ = dice.quaternion.clone(), curX = dice.position.x, curZ = dice.position.z, axis = new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize();
            let frame = 0;
            function anim() {
                frame++; const t = frame/50;
                if (frame <= 50) { dice.position.y = (diceSize/2)+Math.sin(t*Math.PI)*2.5; dice.quaternion.copy(sQ).premultiply(new THREE.Quaternion().setFromAxisAngle(axis, (Math.PI*10)*t)); requestAnimationFrame(anim); }
                else { dice.position.set(curX, diceSize/2, curZ); snapDiceRotation(); showPath(getUpwardFace()); hasMovedSinceLastToss = false; isMoving = false; updateDiceUI(); checkBossUnlock(); }
            }
            anim();
        }

        function flashDice() {
            let f = 0; function anim() {
                f++; const intensity = Math.sin((f/30)*Math.PI)*0.8; dice.material.forEach(m => m.emissive.setRGB(intensity, intensity, 0));
                if (f < 30) requestAnimationFrame(anim); else dice.material.forEach(m => m.emissive.set(0));
            }
            anim();
        }

        async function randomDiceTeleport() {
            if (isMoving || !hasMovedSinceLastToss) { if(!hasMovedSinceLastToss) showMessage("Move First!", "white"); return; }
            if (totalScore < 500) { showMessage("Need 500!"); return; }
            subtractScore(500); const target = new THREE.Vector3(Math.floor(Math.random()*gridSize)-halfBoard, diceSize/2, Math.floor(Math.random()*gridSize)-halfBoard);
            isMoving = true; if (pathGroup) { scene.remove(pathGroup); pathGroup = null; }
            for (let f = 1; f <= 25; f++) {
                const t = f/25; if (f <= 12) dice.scale.set(1-t*2, 1-t*2, 1-t*2); else { dice.position.copy(target); dice.scale.set((f-12)/13, (f-12)/13, (f-12)/13); }
                await new Promise(requestAnimationFrame);
            }
            dice.scale.set(1,1,1); snapDiceRotation(); checkChipCollection(target.x, target.z); hasMovedSinceLastToss = true; isMoving = false; updateDiceUI();
        }

        function generatePointCanvas(point) {
            const c = document.createElement('canvas'); c.width = 256; c.height = 256; const ctx = c.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,256,256); ctx.strokeStyle = '#eeeeee'; ctx.lineWidth = 4; ctx.strokeRect(0,0,256,256);
            ctx.fillStyle = (point === 1 || point === 4) ? '#ff4d4d' : '#333333';
            const posMap = {1:[[128,128]],2:[[70,70],[186,186]],3:[[60,60],[128,128],[196,196]],4:[[75,75],[181,75],[75,181],[181,181]],5:[[75,75],[181,75],[128,128],[75,181],[181,181]],6:[[75,60],[75,128],[75,196],[181,60],[181,128],[181,196]]};
            (posMap[point] || []).forEach(p => { ctx.beginPath(); ctx.arc(p[0],p[1],point===1?48:32,0,Math.PI*2); ctx.fill(); });
            return c;
        }

        function createDice() {
            const mats = []; for(let i=0; i<6; i++) mats.push(new THREE.MeshPhongMaterial({ map: new THREE.CanvasTexture(generatePointCanvas(diceFacePoints[i])), emissive: new THREE.Color(0) }));
            dice = new THREE.Mesh(new THREE.RoundedBoxGeometry(diceSize, diceSize, diceSize, 3, 0.08), mats);
            dice.position.y = diceSize/2; dice.castShadow = true; scene.add(dice);
        }

        function updateCameraPosition() {
            const dist = 9;
            camera.position.set(Math.sin(cameraAzimuth)*Math.cos(cameraPolar)*dist+dice.position.x, Math.sin(cameraPolar)*dist+dice.position.y, Math.sin(cameraAzimuth+Math.PI/2)*Math.cos(cameraPolar)*dist+dice.position.z);
            camera.lookAt(dice.position.x, dice.position.y, dice.position.z);
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function animate() { requestAnimationFrame(animate); updateCameraPosition(); renderer.render(scene, camera); }

        window.onload = init;
    </script>
</body>
</html>
